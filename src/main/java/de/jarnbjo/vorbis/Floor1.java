begin_unit|revision:1.0.0;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * $ProjectName$  * $ProjectRevision$  * -----------------------------------------------------------  * $Id: Floor1.java,v 1.2 2003/03/16 01:11:12 jarnbjo Exp $multip  * -----------------------------------------------------------  *  * $Author: jarnbjo $  *  * Description:  *  * Copyright 2002-2003 Tor-Einar Jarnbjo  * -----------------------------------------------------------  *  * Change History  * -----------------------------------------------------------  * $Log: Floor1.java,v $  * Revision 1.2  2003/03/16 01:11:12  jarnbjo  * no message  *  *  */
end_comment

begin_package
package|package
name|de
operator|.
name|jarnbjo
operator|.
name|vorbis
package|;
end_package

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|*
import|;
end_import

begin_import
import|import
name|de
operator|.
name|jarnbjo
operator|.
name|util
operator|.
name|io
operator|.
name|BitInputStream
import|;
end_import

begin_class
class|class
name|Floor1
extends|extends
name|Floor
implements|implements
name|Cloneable
block|{
specifier|private
name|int
index|[]
name|partitionClassList
decl_stmt|;
specifier|private
name|int
name|maximumClass
decl_stmt|,
name|multiplier
decl_stmt|,
name|rangeBits
decl_stmt|;
specifier|private
name|int
index|[]
name|classDimensions
decl_stmt|;
specifier|private
name|int
index|[]
name|classSubclasses
decl_stmt|;
specifier|private
name|int
index|[]
name|classMasterbooks
decl_stmt|;
specifier|private
name|int
index|[]
index|[]
name|subclassBooks
decl_stmt|;
specifier|private
name|int
index|[]
name|xList
decl_stmt|;
specifier|private
name|int
index|[]
name|yList
decl_stmt|;
specifier|private
name|int
index|[]
name|lowNeighbours
decl_stmt|,
name|highNeighbours
decl_stmt|;
comment|//private boolean[] step2Flags;
specifier|private
specifier|static
specifier|final
name|int
index|[]
name|RANGES
init|=
block|{
literal|256
block|,
literal|128
block|,
literal|86
block|,
literal|64
block|}
decl_stmt|;
specifier|private
name|Floor1
parameter_list|()
block|{
block|}
specifier|protected
name|Floor1
parameter_list|(
name|BitInputStream
name|source
parameter_list|,
name|SetupHeader
name|header
parameter_list|)
throws|throws
name|VorbisFormatException
throws|,
name|IOException
block|{
name|maximumClass
operator|=
operator|-
literal|1
expr_stmt|;
name|int
name|partitions
init|=
name|source
operator|.
name|getInt
argument_list|(
literal|5
argument_list|)
decl_stmt|;
name|partitionClassList
operator|=
operator|new
name|int
index|[
name|partitions
index|]
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|partitionClassList
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|partitionClassList
index|[
name|i
index|]
operator|=
name|source
operator|.
name|getInt
argument_list|(
literal|4
argument_list|)
expr_stmt|;
if|if
condition|(
name|partitionClassList
index|[
name|i
index|]
operator|>
name|maximumClass
condition|)
block|{
name|maximumClass
operator|=
name|partitionClassList
index|[
name|i
index|]
expr_stmt|;
block|}
block|}
name|classDimensions
operator|=
operator|new
name|int
index|[
name|maximumClass
operator|+
literal|1
index|]
expr_stmt|;
name|classSubclasses
operator|=
operator|new
name|int
index|[
name|maximumClass
operator|+
literal|1
index|]
expr_stmt|;
name|classMasterbooks
operator|=
operator|new
name|int
index|[
name|maximumClass
operator|+
literal|1
index|]
expr_stmt|;
name|subclassBooks
operator|=
operator|new
name|int
index|[
name|maximumClass
operator|+
literal|1
index|]
index|[]
expr_stmt|;
name|int
name|xListLength
init|=
literal|2
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<=
name|maximumClass
condition|;
name|i
operator|++
control|)
block|{
name|classDimensions
index|[
name|i
index|]
operator|=
name|source
operator|.
name|getInt
argument_list|(
literal|3
argument_list|)
operator|+
literal|1
expr_stmt|;
name|xListLength
operator|+=
name|classDimensions
index|[
name|i
index|]
expr_stmt|;
name|classSubclasses
index|[
name|i
index|]
operator|=
name|source
operator|.
name|getInt
argument_list|(
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|classDimensions
index|[
name|i
index|]
operator|>
name|header
operator|.
name|getCodeBooks
argument_list|()
operator|.
name|length
operator|||
name|classSubclasses
index|[
name|i
index|]
operator|>
name|header
operator|.
name|getCodeBooks
argument_list|()
operator|.
name|length
condition|)
block|{
throw|throw
operator|new
name|VorbisFormatException
argument_list|(
literal|"There is a class dimension or class subclasses entry higher than the number of codebooks in the setup header."
argument_list|)
throw|;
block|}
if|if
condition|(
name|classSubclasses
index|[
name|i
index|]
operator|!=
literal|0
condition|)
block|{
name|classMasterbooks
index|[
name|i
index|]
operator|=
name|source
operator|.
name|getInt
argument_list|(
literal|8
argument_list|)
expr_stmt|;
block|}
name|subclassBooks
index|[
name|i
index|]
operator|=
operator|new
name|int
index|[
literal|1
operator|<<
name|classSubclasses
index|[
name|i
index|]
index|]
expr_stmt|;
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
name|subclassBooks
index|[
name|i
index|]
operator|.
name|length
condition|;
name|j
operator|++
control|)
block|{
name|subclassBooks
index|[
name|i
index|]
index|[
name|j
index|]
operator|=
name|source
operator|.
name|getInt
argument_list|(
literal|8
argument_list|)
operator|-
literal|1
expr_stmt|;
block|}
block|}
name|multiplier
operator|=
name|source
operator|.
name|getInt
argument_list|(
literal|2
argument_list|)
operator|+
literal|1
expr_stmt|;
name|rangeBits
operator|=
name|source
operator|.
name|getInt
argument_list|(
literal|4
argument_list|)
expr_stmt|;
comment|//System.out.println("multiplier: "+multiplier);
comment|//System.out.println("rangeBits: "+rangeBits);
comment|//System.out.println("xListLength: "+xListLength);
name|int
name|floorValues
init|=
literal|0
decl_stmt|;
name|ArrayList
name|alXList
init|=
operator|new
name|ArrayList
argument_list|()
decl_stmt|;
name|alXList
operator|.
name|add
argument_list|(
operator|new
name|Integer
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|alXList
operator|.
name|add
argument_list|(
operator|new
name|Integer
argument_list|(
literal|1
operator|<<
name|rangeBits
argument_list|)
argument_list|)
expr_stmt|;
comment|//System.out.println("partitions: "+partitions);
comment|//System.out.println("classDimensions.length: "+classDimensions.length);
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|partitions
condition|;
name|i
operator|++
control|)
block|{
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
name|classDimensions
index|[
name|partitionClassList
index|[
name|i
index|]
index|]
condition|;
name|j
operator|++
control|)
block|{
name|alXList
operator|.
name|add
argument_list|(
operator|new
name|Integer
argument_list|(
name|source
operator|.
name|getInt
argument_list|(
name|rangeBits
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|xList
operator|=
operator|new
name|int
index|[
name|alXList
operator|.
name|size
argument_list|()
index|]
expr_stmt|;
name|lowNeighbours
operator|=
operator|new
name|int
index|[
name|xList
operator|.
name|length
index|]
expr_stmt|;
name|highNeighbours
operator|=
operator|new
name|int
index|[
name|xList
operator|.
name|length
index|]
expr_stmt|;
name|Iterator
name|iter
init|=
name|alXList
operator|.
name|iterator
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|xList
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|xList
index|[
name|i
index|]
operator|=
operator|(
operator|(
name|Integer
operator|)
name|iter
operator|.
name|next
argument_list|()
operator|)
operator|.
name|intValue
argument_list|()
expr_stmt|;
block|}
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|xList
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|lowNeighbours
index|[
name|i
index|]
operator|=
name|Util
operator|.
name|lowNeighbour
argument_list|(
name|xList
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|highNeighbours
index|[
name|i
index|]
operator|=
name|Util
operator|.
name|highNeighbour
argument_list|(
name|xList
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
block|}
specifier|protected
name|int
name|getType
parameter_list|()
block|{
return|return
literal|1
return|;
block|}
specifier|protected
name|Floor
name|decodeFloor
parameter_list|(
name|VorbisStream
name|vorbis
parameter_list|,
name|BitInputStream
name|source
parameter_list|)
throws|throws
name|VorbisFormatException
throws|,
name|IOException
block|{
comment|//System.out.println("decodeFloor");
if|if
condition|(
operator|!
name|source
operator|.
name|getBit
argument_list|()
condition|)
block|{
comment|//System.out.println("null");
return|return
literal|null
return|;
block|}
name|Floor1
name|clone
init|=
operator|(
name|Floor1
operator|)
name|clone
argument_list|()
decl_stmt|;
name|clone
operator|.
name|yList
operator|=
operator|new
name|int
index|[
name|xList
operator|.
name|length
index|]
expr_stmt|;
name|int
name|range
init|=
name|RANGES
index|[
name|multiplier
operator|-
literal|1
index|]
decl_stmt|;
name|clone
operator|.
name|yList
index|[
literal|0
index|]
operator|=
name|source
operator|.
name|getInt
argument_list|(
name|Util
operator|.
name|ilog
argument_list|(
name|range
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|clone
operator|.
name|yList
index|[
literal|1
index|]
operator|=
name|source
operator|.
name|getInt
argument_list|(
name|Util
operator|.
name|ilog
argument_list|(
name|range
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|int
name|offset
init|=
literal|2
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|partitionClassList
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|int
name|cls
init|=
name|partitionClassList
index|[
name|i
index|]
decl_stmt|;
name|int
name|cdim
init|=
name|classDimensions
index|[
name|cls
index|]
decl_stmt|;
name|int
name|cbits
init|=
name|classSubclasses
index|[
name|cls
index|]
decl_stmt|;
name|int
name|csub
init|=
operator|(
literal|1
operator|<<
name|cbits
operator|)
operator|-
literal|1
decl_stmt|;
name|int
name|cval
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|cbits
operator|>
literal|0
condition|)
block|{
name|cval
operator|=
name|source
operator|.
name|getInt
argument_list|(
name|vorbis
operator|.
name|getSetupHeader
argument_list|()
operator|.
name|getCodeBooks
argument_list|()
index|[
name|classMasterbooks
index|[
name|cls
index|]
index|]
operator|.
name|getHuffmanRoot
argument_list|()
argument_list|)
expr_stmt|;
comment|//cval=vorbis.getSetupHeader().getCodeBooks()[classMasterbooks[cls]].readInt(source);
comment|//System.out.println("cval: "+cval);
block|}
comment|//System.out.println("0: "+cls+" "+cdim+" "+cbits+" "+csub+" "+cval);
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
name|cdim
condition|;
name|j
operator|++
control|)
block|{
comment|//System.out.println("a: "+cls+" "+cval+" "+csub);
name|int
name|book
init|=
name|subclassBooks
index|[
name|cls
index|]
index|[
name|cval
operator|&
name|csub
index|]
decl_stmt|;
name|cval
operator|>>>=
name|cbits
expr_stmt|;
if|if
condition|(
name|book
operator|>=
literal|0
condition|)
block|{
name|clone
operator|.
name|yList
index|[
name|j
operator|+
name|offset
index|]
operator|=
name|source
operator|.
name|getInt
argument_list|(
name|vorbis
operator|.
name|getSetupHeader
argument_list|()
operator|.
name|getCodeBooks
argument_list|()
index|[
name|book
index|]
operator|.
name|getHuffmanRoot
argument_list|()
argument_list|)
expr_stmt|;
comment|//clone.yList[j+offset]=vorbis.getSetupHeader().getCodeBooks()[book].readInt(source);
comment|//System.out.println("b: "+(j+offset)+" "+book+" "+clone.yList[j+offset]);
comment|//System.out.println("");
block|}
else|else
block|{
name|clone
operator|.
name|yList
index|[
name|j
operator|+
name|offset
index|]
operator|=
literal|0
expr_stmt|;
block|}
block|}
name|offset
operator|+=
name|cdim
expr_stmt|;
block|}
comment|//System.out.println("");
comment|//for(int i=0; i<clone.xList.length; i++) {
comment|//   System.out.println(i+" = "+clone.xList[i]);
comment|//}
comment|//System.out.println("");
comment|//for(int i=0; i<clone.yList.length; i++) {
comment|//   System.out.println(i+" = "+clone.yList[i]);
comment|//}
comment|//System.out.println("offset: "+offset);
comment|//System.out.println("yList.length: "+clone.yList.length);
comment|//System.exit(0);
return|return
name|clone
return|;
block|}
specifier|protected
name|void
name|computeFloor
parameter_list|(
specifier|final
name|float
index|[]
name|vector
parameter_list|)
block|{
name|int
name|n
init|=
name|vector
operator|.
name|length
decl_stmt|;
specifier|final
name|int
name|values
init|=
name|xList
operator|.
name|length
decl_stmt|;
specifier|final
name|boolean
index|[]
name|step2Flags
init|=
operator|new
name|boolean
index|[
name|values
index|]
decl_stmt|;
specifier|final
name|int
name|range
init|=
name|RANGES
index|[
name|multiplier
operator|-
literal|1
index|]
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|2
init|;
name|i
operator|<
name|values
condition|;
name|i
operator|++
control|)
block|{
specifier|final
name|int
name|lowNeighbourOffset
init|=
name|lowNeighbours
index|[
name|i
index|]
decl_stmt|;
comment|//Util.lowNeighbour(xList, i);
specifier|final
name|int
name|highNeighbourOffset
init|=
name|highNeighbours
index|[
name|i
index|]
decl_stmt|;
comment|//Util.highNeighbour(xList, i);
specifier|final
name|int
name|predicted
init|=
name|Util
operator|.
name|renderPoint
argument_list|(
name|xList
index|[
name|lowNeighbourOffset
index|]
argument_list|,
name|xList
index|[
name|highNeighbourOffset
index|]
argument_list|,
name|yList
index|[
name|lowNeighbourOffset
index|]
argument_list|,
name|yList
index|[
name|highNeighbourOffset
index|]
argument_list|,
name|xList
index|[
name|i
index|]
argument_list|)
decl_stmt|;
specifier|final
name|int
name|val
init|=
name|yList
index|[
name|i
index|]
decl_stmt|;
specifier|final
name|int
name|highRoom
init|=
name|range
operator|-
name|predicted
decl_stmt|;
specifier|final
name|int
name|lowRoom
init|=
name|predicted
decl_stmt|;
specifier|final
name|int
name|room
init|=
name|highRoom
operator|<
name|lowRoom
condition|?
name|highRoom
operator|*
literal|2
else|:
name|lowRoom
operator|*
literal|2
decl_stmt|;
if|if
condition|(
name|val
operator|!=
literal|0
condition|)
block|{
name|step2Flags
index|[
name|lowNeighbourOffset
index|]
operator|=
literal|true
expr_stmt|;
name|step2Flags
index|[
name|highNeighbourOffset
index|]
operator|=
literal|true
expr_stmt|;
name|step2Flags
index|[
name|i
index|]
operator|=
literal|true
expr_stmt|;
if|if
condition|(
name|val
operator|>=
name|room
condition|)
block|{
name|yList
index|[
name|i
index|]
operator|=
name|highRoom
operator|>
name|lowRoom
condition|?
name|val
operator|-
name|lowRoom
operator|+
name|predicted
else|:
operator|-
name|val
operator|+
name|highRoom
operator|+
name|predicted
operator|-
literal|1
expr_stmt|;
block|}
else|else
block|{
name|yList
index|[
name|i
index|]
operator|=
operator|(
name|val
operator|&
literal|1
operator|)
operator|==
literal|1
condition|?
name|predicted
operator|-
operator|(
operator|(
name|val
operator|+
literal|1
operator|)
operator|>>
literal|1
operator|)
else|:
name|predicted
operator|+
operator|(
name|val
operator|>>
literal|1
operator|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|step2Flags
index|[
name|i
index|]
operator|=
literal|false
expr_stmt|;
name|yList
index|[
name|i
index|]
operator|=
name|predicted
expr_stmt|;
block|}
block|}
specifier|final
name|int
index|[]
name|xList2
init|=
operator|new
name|int
index|[
name|values
index|]
decl_stmt|;
name|System
operator|.
name|arraycopy
argument_list|(
name|xList
argument_list|,
literal|0
argument_list|,
name|xList2
argument_list|,
literal|0
argument_list|,
name|values
argument_list|)
expr_stmt|;
name|sort
argument_list|(
name|xList2
argument_list|,
name|yList
argument_list|,
name|step2Flags
argument_list|)
expr_stmt|;
name|int
name|hx
init|=
literal|0
decl_stmt|,
name|hy
init|=
literal|0
decl_stmt|,
name|lx
init|=
literal|0
decl_stmt|,
name|ly
init|=
name|yList
index|[
literal|0
index|]
operator|*
name|multiplier
decl_stmt|;
name|float
index|[]
name|vector2
init|=
operator|new
name|float
index|[
name|vector
operator|.
name|length
index|]
decl_stmt|;
name|float
index|[]
name|vector3
init|=
operator|new
name|float
index|[
name|vector
operator|.
name|length
index|]
decl_stmt|;
name|Arrays
operator|.
name|fill
argument_list|(
name|vector2
argument_list|,
literal|1.0f
argument_list|)
expr_stmt|;
name|System
operator|.
name|arraycopy
argument_list|(
name|vector
argument_list|,
literal|0
argument_list|,
name|vector3
argument_list|,
literal|0
argument_list|,
name|vector
operator|.
name|length
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|1
init|;
name|i
operator|<
name|values
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|step2Flags
index|[
name|i
index|]
condition|)
block|{
name|hy
operator|=
name|yList
index|[
name|i
index|]
operator|*
name|multiplier
expr_stmt|;
name|hx
operator|=
name|xList2
index|[
name|i
index|]
expr_stmt|;
name|Util
operator|.
name|renderLine
argument_list|(
name|lx
argument_list|,
name|ly
argument_list|,
name|hx
argument_list|,
name|hy
argument_list|,
name|vector
argument_list|)
expr_stmt|;
name|Util
operator|.
name|renderLine
argument_list|(
name|lx
argument_list|,
name|ly
argument_list|,
name|hx
argument_list|,
name|hy
argument_list|,
name|vector2
argument_list|)
expr_stmt|;
name|lx
operator|=
name|hx
expr_stmt|;
name|ly
operator|=
name|hy
expr_stmt|;
block|}
block|}
specifier|final
name|float
name|r
init|=
name|DB_STATIC_TABLE
index|[
name|hy
index|]
decl_stmt|;
for|for
control|(
init|;
name|hx
operator|<
name|n
operator|/
literal|2
condition|;
name|vector
index|[
name|hx
operator|++
index|]
operator|=
name|r
control|)
empty_stmt|;
block|}
specifier|public
name|Object
name|clone
parameter_list|()
block|{
name|Floor1
name|clone
init|=
operator|new
name|Floor1
argument_list|()
decl_stmt|;
name|clone
operator|.
name|classDimensions
operator|=
name|classDimensions
expr_stmt|;
name|clone
operator|.
name|classMasterbooks
operator|=
name|classMasterbooks
expr_stmt|;
name|clone
operator|.
name|classSubclasses
operator|=
name|classSubclasses
expr_stmt|;
name|clone
operator|.
name|maximumClass
operator|=
name|maximumClass
expr_stmt|;
name|clone
operator|.
name|multiplier
operator|=
name|multiplier
expr_stmt|;
name|clone
operator|.
name|partitionClassList
operator|=
name|partitionClassList
expr_stmt|;
name|clone
operator|.
name|rangeBits
operator|=
name|rangeBits
expr_stmt|;
name|clone
operator|.
name|subclassBooks
operator|=
name|subclassBooks
expr_stmt|;
name|clone
operator|.
name|xList
operator|=
name|xList
expr_stmt|;
name|clone
operator|.
name|yList
operator|=
name|yList
expr_stmt|;
name|clone
operator|.
name|lowNeighbours
operator|=
name|lowNeighbours
expr_stmt|;
name|clone
operator|.
name|highNeighbours
operator|=
name|highNeighbours
expr_stmt|;
return|return
name|clone
return|;
block|}
specifier|private
specifier|final
specifier|static
name|void
name|sort
parameter_list|(
name|int
name|x
index|[]
parameter_list|,
name|int
name|y
index|[]
parameter_list|,
name|boolean
name|b
index|[]
parameter_list|)
block|{
name|int
name|off
init|=
literal|0
decl_stmt|;
name|int
name|len
init|=
name|x
operator|.
name|length
decl_stmt|;
name|int
name|lim
init|=
name|len
operator|+
name|off
decl_stmt|;
name|int
name|itmp
decl_stmt|;
name|boolean
name|btmp
decl_stmt|;
comment|// Insertion sort on smallest arrays
for|for
control|(
name|int
name|i
init|=
name|off
init|;
name|i
operator|<
name|lim
condition|;
name|i
operator|++
control|)
block|{
for|for
control|(
name|int
name|j
init|=
name|i
init|;
name|j
operator|>
name|off
operator|&&
name|x
index|[
name|j
operator|-
literal|1
index|]
operator|>
name|x
index|[
name|j
index|]
condition|;
name|j
operator|--
control|)
block|{
name|itmp
operator|=
name|x
index|[
name|j
index|]
expr_stmt|;
name|x
index|[
name|j
index|]
operator|=
name|x
index|[
name|j
operator|-
literal|1
index|]
expr_stmt|;
name|x
index|[
name|j
operator|-
literal|1
index|]
operator|=
name|itmp
expr_stmt|;
name|itmp
operator|=
name|y
index|[
name|j
index|]
expr_stmt|;
name|y
index|[
name|j
index|]
operator|=
name|y
index|[
name|j
operator|-
literal|1
index|]
expr_stmt|;
name|y
index|[
name|j
operator|-
literal|1
index|]
operator|=
name|itmp
expr_stmt|;
name|btmp
operator|=
name|b
index|[
name|j
index|]
expr_stmt|;
name|b
index|[
name|j
index|]
operator|=
name|b
index|[
name|j
operator|-
literal|1
index|]
expr_stmt|;
name|b
index|[
name|j
operator|-
literal|1
index|]
operator|=
name|btmp
expr_stmt|;
comment|//swap(x, j, j-1);
comment|//swap(y, j, j-1);
comment|//swap(b, j, j-1);
block|}
block|}
block|}
specifier|private
specifier|final
specifier|static
name|void
name|swap
parameter_list|(
name|int
name|x
index|[]
parameter_list|,
name|int
name|a
parameter_list|,
name|int
name|b
parameter_list|)
block|{
name|int
name|t
init|=
name|x
index|[
name|a
index|]
decl_stmt|;
name|x
index|[
name|a
index|]
operator|=
name|x
index|[
name|b
index|]
expr_stmt|;
name|x
index|[
name|b
index|]
operator|=
name|t
expr_stmt|;
block|}
specifier|private
specifier|final
specifier|static
name|void
name|swap
parameter_list|(
name|boolean
name|x
index|[]
parameter_list|,
name|int
name|a
parameter_list|,
name|int
name|b
parameter_list|)
block|{
name|boolean
name|t
init|=
name|x
index|[
name|a
index|]
decl_stmt|;
name|x
index|[
name|a
index|]
operator|=
name|x
index|[
name|b
index|]
expr_stmt|;
name|x
index|[
name|b
index|]
operator|=
name|t
expr_stmt|;
block|}
block|}
end_class

end_unit

