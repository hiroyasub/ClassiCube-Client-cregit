begin_unit|revision:1.0.0;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * $ProjectName$  * $ProjectRevision$  * -----------------------------------------------------------  * $Id: OggPage.java,v 1.3 2003/04/10 19:48:22 jarnbjo Exp $  * -----------------------------------------------------------  *  * $Author: jarnbjo $  *  * Description:  *  * Copyright 2002-2003 Tor-Einar Jarnbjo  * -----------------------------------------------------------  *  * Change History  * -----------------------------------------------------------  * $Log: OggPage.java,v $  * Revision 1.3  2003/04/10 19:48:22  jarnbjo  * no message  *  * Revision 1.2  2003/03/31 00:23:04  jarnbjo  * no message  *  * Revision 1.1  2003/03/03 21:02:20  jarnbjo  * no message  *  */
end_comment

begin_package
package|package
name|de
operator|.
name|jarnbjo
operator|.
name|ogg
package|;
end_package

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|*
import|;
end_import

begin_import
import|import
name|de
operator|.
name|jarnbjo
operator|.
name|util
operator|.
name|io
operator|.
name|*
import|;
end_import

begin_comment
comment|/**  *<p>  * An instance of this class represents an ogg page read from an ogg file or  * network stream. It has no public constructor, but instances can be created by  * the<code>create</code> methods, supplying a JMF stream or a  *<code>RandomAccessFile</code> which is positioned at the beginning of an Ogg  * page.  *</p>  *   *<p>  * Furtheron, the class provides methods for accessing the raw page data, as  * well as data attributes like segmenting information, sequence number, stream  * serial number, chechsum and wether this page is the beginning or end of a  * logical bitstream (BOS, EOS) and if the page data starts with a continued  * packet or a fresh data packet.  *</p>  */
end_comment

begin_class
specifier|public
class|class
name|OggPage
block|{
specifier|private
name|int
name|version
decl_stmt|;
specifier|private
name|boolean
name|continued
decl_stmt|,
name|bos
decl_stmt|,
name|eos
decl_stmt|;
specifier|private
name|long
name|absoluteGranulePosition
decl_stmt|;
specifier|private
name|int
name|streamSerialNumber
decl_stmt|,
name|pageSequenceNumber
decl_stmt|,
name|pageCheckSum
decl_stmt|;
specifier|private
name|int
index|[]
name|segmentOffsets
decl_stmt|;
specifier|private
name|int
index|[]
name|segmentLengths
decl_stmt|;
specifier|private
name|int
name|totalLength
decl_stmt|;
specifier|private
name|byte
index|[]
name|header
decl_stmt|,
name|segmentTable
decl_stmt|,
name|data
decl_stmt|;
specifier|protected
name|OggPage
parameter_list|()
block|{
block|}
specifier|private
name|OggPage
parameter_list|(
name|int
name|version
parameter_list|,
name|boolean
name|continued
parameter_list|,
name|boolean
name|bos
parameter_list|,
name|boolean
name|eos
parameter_list|,
name|long
name|absoluteGranulePosition
parameter_list|,
name|int
name|streamSerialNumber
parameter_list|,
name|int
name|pageSequenceNumber
parameter_list|,
name|int
name|pageCheckSum
parameter_list|,
name|int
index|[]
name|segmentOffsets
parameter_list|,
name|int
index|[]
name|segmentLengths
parameter_list|,
name|int
name|totalLength
parameter_list|,
name|byte
index|[]
name|header
parameter_list|,
name|byte
index|[]
name|segmentTable
parameter_list|,
name|byte
index|[]
name|data
parameter_list|)
block|{
name|this
operator|.
name|version
operator|=
name|version
expr_stmt|;
name|this
operator|.
name|continued
operator|=
name|continued
expr_stmt|;
name|this
operator|.
name|bos
operator|=
name|bos
expr_stmt|;
name|this
operator|.
name|eos
operator|=
name|eos
expr_stmt|;
name|this
operator|.
name|absoluteGranulePosition
operator|=
name|absoluteGranulePosition
expr_stmt|;
name|this
operator|.
name|streamSerialNumber
operator|=
name|streamSerialNumber
expr_stmt|;
name|this
operator|.
name|pageSequenceNumber
operator|=
name|pageSequenceNumber
expr_stmt|;
name|this
operator|.
name|pageCheckSum
operator|=
name|pageCheckSum
expr_stmt|;
name|this
operator|.
name|segmentOffsets
operator|=
name|segmentOffsets
expr_stmt|;
name|this
operator|.
name|segmentLengths
operator|=
name|segmentLengths
expr_stmt|;
name|this
operator|.
name|totalLength
operator|=
name|totalLength
expr_stmt|;
name|this
operator|.
name|header
operator|=
name|header
expr_stmt|;
name|this
operator|.
name|segmentTable
operator|=
name|segmentTable
expr_stmt|;
name|this
operator|.
name|data
operator|=
name|data
expr_stmt|;
block|}
comment|/**      * this method equals to create(RandomAccessFile source, false)      *       * @see #create(RandomAccessFile, boolean)      */
specifier|public
specifier|static
name|OggPage
name|create
parameter_list|(
name|RandomAccessFile
name|source
parameter_list|)
throws|throws
name|IOException
throws|,
name|EndOfOggStreamException
throws|,
name|OggFormatException
block|{
return|return
name|create
argument_list|(
name|source
argument_list|,
literal|false
argument_list|)
return|;
block|}
comment|/**      * This method is called to read data from the current position in the      * specified RandomAccessFile and create a new OggPage instance based on the      * data read. If the parameter<code>skipData</code> is set to      *<code>true</code>, the actual page segments (page data) is skipped and      * not read into memory. This mode is useful when scanning through an ogg      * file to build a seek table.      *       * @param source      *            the source from which the ogg page is generated      * @param skipData      *            if set to<code>true</code>, the actual page data is not read      *            into memory      * @return an ogg page created by reading data from the specified source,      *         starting at the current position      * @throws FormatException      *             if the data read from the specified source is not matching      *             the specification for an ogg page      * @throws EndOfStreamException      *             if it is not possible to read an entire ogg page from the      *             specified source      * @throws IOException      *             if some other I/O error is detected when reading from the      *             source      *       * @see #create(RandomAccessFile)      */
specifier|public
specifier|static
name|OggPage
name|create
parameter_list|(
name|RandomAccessFile
name|source
parameter_list|,
name|boolean
name|skipData
parameter_list|)
throws|throws
name|IOException
throws|,
name|EndOfOggStreamException
throws|,
name|OggFormatException
block|{
return|return
name|create
argument_list|(
operator|(
name|Object
operator|)
name|source
argument_list|,
name|skipData
argument_list|)
return|;
block|}
comment|/**      * this method equals to create(InputStream source, false)      *       * @see #create(InputStream, boolean)      */
specifier|public
specifier|static
name|OggPage
name|create
parameter_list|(
name|InputStream
name|source
parameter_list|)
throws|throws
name|IOException
throws|,
name|EndOfOggStreamException
throws|,
name|OggFormatException
block|{
return|return
name|create
argument_list|(
name|source
argument_list|,
literal|false
argument_list|)
return|;
block|}
comment|/**      * This method is called to read data from the current position in the      * specified InpuStream and create a new OggPage instance based on the data      * read. If the parameter<code>skipData</code> is set to<code>true</code>,      * the actual page segments (page data) is skipped and not read into memory.      * This mode is useful when scanning through an ogg file to build a seek      * table.      *       * @param source      *            the source from which the ogg page is generated      * @param skipData      *            if set to<code>true</code>, the actual page data is not read      *            into memory      * @return an ogg page created by reading data from the specified source,      *         starting at the current position      * @throws FormatException      *             if the data read from the specified source is not matching      *             the specification for an ogg page      * @throws EndOfStreamException      *             if it is not possible to read an entire ogg page from the      *             specified source      * @throws IOException      *             if some other I/O error is detected when reading from the      *             source      *       * @see #create(InputStream)      */
specifier|public
specifier|static
name|OggPage
name|create
parameter_list|(
name|InputStream
name|source
parameter_list|,
name|boolean
name|skipData
parameter_list|)
throws|throws
name|IOException
throws|,
name|EndOfOggStreamException
throws|,
name|OggFormatException
block|{
return|return
name|create
argument_list|(
operator|(
name|Object
operator|)
name|source
argument_list|,
name|skipData
argument_list|)
return|;
block|}
comment|/**      * this method equals to create(byte[] source, false)      *       * @see #create(byte[], boolean)      */
specifier|public
specifier|static
name|OggPage
name|create
parameter_list|(
name|byte
index|[]
name|source
parameter_list|)
throws|throws
name|IOException
throws|,
name|EndOfOggStreamException
throws|,
name|OggFormatException
block|{
return|return
name|create
argument_list|(
name|source
argument_list|,
literal|false
argument_list|)
return|;
block|}
comment|/**      * This method is called to create a new OggPage instance based on the      * specified byte array.      *       * @param source      *            the source from which the ogg page is generated      * @param skipData      *            if set to<code>true</code>, the actual page data is not read      *            into memory      * @return an ogg page created by reading data from the specified source,      *         starting at the current position      * @throws FormatException      *             if the data read from the specified source is not matching      *             the specification for an ogg page      * @throws EndOfStreamException      *             if it is not possible to read an entire ogg page from the      *             specified source      * @throws IOException      *             if some other I/O error is detected when reading from the      *             source      *       * @see #create(byte[])      */
specifier|public
specifier|static
name|OggPage
name|create
parameter_list|(
name|byte
index|[]
name|source
parameter_list|,
name|boolean
name|skipData
parameter_list|)
throws|throws
name|IOException
throws|,
name|EndOfOggStreamException
throws|,
name|OggFormatException
block|{
return|return
name|create
argument_list|(
operator|(
name|Object
operator|)
name|source
argument_list|,
name|skipData
argument_list|)
return|;
block|}
specifier|private
specifier|static
name|OggPage
name|create
parameter_list|(
name|Object
name|source
parameter_list|,
name|boolean
name|skipData
parameter_list|)
throws|throws
name|IOException
throws|,
name|EndOfOggStreamException
throws|,
name|OggFormatException
block|{
try|try
block|{
name|int
name|sourceOffset
init|=
literal|27
decl_stmt|;
name|byte
index|[]
name|header
init|=
operator|new
name|byte
index|[
literal|27
index|]
decl_stmt|;
if|if
condition|(
name|source
operator|instanceof
name|RandomAccessFile
condition|)
block|{
name|RandomAccessFile
name|raf
init|=
operator|(
name|RandomAccessFile
operator|)
name|source
decl_stmt|;
if|if
condition|(
name|raf
operator|.
name|getFilePointer
argument_list|()
operator|==
name|raf
operator|.
name|length
argument_list|()
condition|)
block|{
return|return
literal|null
return|;
block|}
name|raf
operator|.
name|readFully
argument_list|(
name|header
argument_list|)
expr_stmt|;
block|}
if|else if
condition|(
name|source
operator|instanceof
name|InputStream
condition|)
block|{
name|readFully
argument_list|(
operator|(
name|InputStream
operator|)
name|source
argument_list|,
name|header
argument_list|)
expr_stmt|;
block|}
if|else if
condition|(
name|source
operator|instanceof
name|byte
index|[]
condition|)
block|{
name|System
operator|.
name|arraycopy
argument_list|(
operator|(
name|byte
index|[]
operator|)
name|source
argument_list|,
literal|0
argument_list|,
name|header
argument_list|,
literal|0
argument_list|,
literal|27
argument_list|)
expr_stmt|;
block|}
name|BitInputStream
name|bdSource
init|=
operator|new
name|ByteArrayBitInputStream
argument_list|(
name|header
argument_list|)
decl_stmt|;
name|int
name|capture
init|=
name|bdSource
operator|.
name|getInt
argument_list|(
literal|32
argument_list|)
decl_stmt|;
if|if
condition|(
name|capture
operator|!=
literal|0x5367674f
condition|)
block|{
comment|// throw new
comment|// FormatException("Ogg page does not start with 'OggS' (0x4f676753)");
comment|/* 		 * * This condition is IMHO an error, but older Ogg files often 		 * contain* pages with a different capture than OggS. I am not 		 * sure how to* manage these pages, but the decoder seems to 		 * work properly, if* the incorrect capture is simply ignored. 		 */
name|String
name|cs
init|=
name|Integer
operator|.
name|toHexString
argument_list|(
name|capture
argument_list|)
decl_stmt|;
while|while
condition|(
name|cs
operator|.
name|length
argument_list|()
operator|<
literal|8
condition|)
block|{
name|cs
operator|=
literal|"0"
operator|+
name|cs
expr_stmt|;
block|}
name|cs
operator|=
name|cs
operator|.
name|substring
argument_list|(
literal|6
argument_list|,
literal|8
argument_list|)
operator|+
name|cs
operator|.
name|substring
argument_list|(
literal|4
argument_list|,
literal|6
argument_list|)
operator|+
name|cs
operator|.
name|substring
argument_list|(
literal|2
argument_list|,
literal|4
argument_list|)
operator|+
name|cs
operator|.
name|substring
argument_list|(
literal|0
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|char
name|c1
init|=
operator|(
name|char
operator|)
operator|(
name|Integer
operator|.
name|valueOf
argument_list|(
name|cs
operator|.
name|substring
argument_list|(
literal|0
argument_list|,
literal|2
argument_list|)
argument_list|,
literal|16
argument_list|)
operator|.
name|intValue
argument_list|()
operator|)
decl_stmt|;
name|char
name|c2
init|=
operator|(
name|char
operator|)
operator|(
name|Integer
operator|.
name|valueOf
argument_list|(
name|cs
operator|.
name|substring
argument_list|(
literal|2
argument_list|,
literal|4
argument_list|)
argument_list|,
literal|16
argument_list|)
operator|.
name|intValue
argument_list|()
operator|)
decl_stmt|;
name|char
name|c3
init|=
operator|(
name|char
operator|)
operator|(
name|Integer
operator|.
name|valueOf
argument_list|(
name|cs
operator|.
name|substring
argument_list|(
literal|4
argument_list|,
literal|6
argument_list|)
argument_list|,
literal|16
argument_list|)
operator|.
name|intValue
argument_list|()
operator|)
decl_stmt|;
name|char
name|c4
init|=
operator|(
name|char
operator|)
operator|(
name|Integer
operator|.
name|valueOf
argument_list|(
name|cs
operator|.
name|substring
argument_list|(
literal|6
argument_list|,
literal|8
argument_list|)
argument_list|,
literal|16
argument_list|)
operator|.
name|intValue
argument_list|()
operator|)
decl_stmt|;
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"Ogg packet header is 0x"
operator|+
name|cs
operator|+
literal|" ("
operator|+
name|c1
operator|+
name|c2
operator|+
name|c3
operator|+
name|c4
operator|+
literal|"), should be 0x4f676753 (OggS)"
argument_list|)
expr_stmt|;
block|}
name|int
name|version
init|=
name|bdSource
operator|.
name|getInt
argument_list|(
literal|8
argument_list|)
decl_stmt|;
name|byte
name|tmp
init|=
operator|(
name|byte
operator|)
name|bdSource
operator|.
name|getInt
argument_list|(
literal|8
argument_list|)
decl_stmt|;
name|boolean
name|bf1
init|=
operator|(
name|tmp
operator|&
literal|1
operator|)
operator|!=
literal|0
decl_stmt|;
name|boolean
name|bos
init|=
operator|(
name|tmp
operator|&
literal|2
operator|)
operator|!=
literal|0
decl_stmt|;
name|boolean
name|eos
init|=
operator|(
name|tmp
operator|&
literal|4
operator|)
operator|!=
literal|0
decl_stmt|;
name|long
name|absoluteGranulePosition
init|=
name|bdSource
operator|.
name|getLong
argument_list|(
literal|64
argument_list|)
decl_stmt|;
name|int
name|streamSerialNumber
init|=
name|bdSource
operator|.
name|getInt
argument_list|(
literal|32
argument_list|)
decl_stmt|;
name|int
name|pageSequenceNumber
init|=
name|bdSource
operator|.
name|getInt
argument_list|(
literal|32
argument_list|)
decl_stmt|;
name|int
name|pageCheckSum
init|=
name|bdSource
operator|.
name|getInt
argument_list|(
literal|32
argument_list|)
decl_stmt|;
name|int
name|pageSegments
init|=
name|bdSource
operator|.
name|getInt
argument_list|(
literal|8
argument_list|)
decl_stmt|;
comment|// System.out.println("OggPage: "+streamSerialNumber+" / "+absoluteGranulePosition+" / "+pageSequenceNumber);
name|int
index|[]
name|segmentOffsets
init|=
operator|new
name|int
index|[
name|pageSegments
index|]
decl_stmt|;
name|int
index|[]
name|segmentLengths
init|=
operator|new
name|int
index|[
name|pageSegments
index|]
decl_stmt|;
name|int
name|totalLength
init|=
literal|0
decl_stmt|;
name|byte
index|[]
name|segmentTable
init|=
operator|new
name|byte
index|[
name|pageSegments
index|]
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|pageSegments
condition|;
name|i
operator|++
control|)
block|{
name|int
name|l
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|source
operator|instanceof
name|RandomAccessFile
condition|)
block|{
name|l
operator|=
operator|(
operator|(
name|int
operator|)
operator|(
operator|(
name|RandomAccessFile
operator|)
name|source
operator|)
operator|.
name|readByte
argument_list|()
operator|&
literal|0xff
operator|)
expr_stmt|;
block|}
if|else if
condition|(
name|source
operator|instanceof
name|InputStream
condition|)
block|{
name|l
operator|=
operator|(
name|int
operator|)
operator|(
operator|(
name|InputStream
operator|)
name|source
operator|)
operator|.
name|read
argument_list|()
expr_stmt|;
block|}
if|else if
condition|(
name|source
operator|instanceof
name|byte
index|[]
condition|)
block|{
name|l
operator|=
operator|(
name|int
operator|)
operator|(
operator|(
name|byte
index|[]
operator|)
name|source
operator|)
index|[
name|sourceOffset
operator|++
index|]
expr_stmt|;
name|l
operator|&=
literal|255
expr_stmt|;
block|}
name|segmentTable
index|[
name|i
index|]
operator|=
operator|(
name|byte
operator|)
name|l
expr_stmt|;
name|segmentLengths
index|[
name|i
index|]
operator|=
name|l
expr_stmt|;
name|segmentOffsets
index|[
name|i
index|]
operator|=
name|totalLength
expr_stmt|;
name|totalLength
operator|+=
name|l
expr_stmt|;
block|}
name|byte
index|[]
name|data
init|=
literal|null
decl_stmt|;
if|if
condition|(
operator|!
name|skipData
condition|)
block|{
comment|// System.out.println("createPage: "+absoluteGranulePosition*1000/44100);
name|data
operator|=
operator|new
name|byte
index|[
name|totalLength
index|]
expr_stmt|;
comment|// source.read(data, 0, totalLength);
if|if
condition|(
name|source
operator|instanceof
name|RandomAccessFile
condition|)
block|{
operator|(
operator|(
name|RandomAccessFile
operator|)
name|source
operator|)
operator|.
name|readFully
argument_list|(
name|data
argument_list|)
expr_stmt|;
block|}
if|else if
condition|(
name|source
operator|instanceof
name|InputStream
condition|)
block|{
name|readFully
argument_list|(
operator|(
name|InputStream
operator|)
name|source
argument_list|,
name|data
argument_list|)
expr_stmt|;
block|}
if|else if
condition|(
name|source
operator|instanceof
name|byte
index|[]
condition|)
block|{
name|System
operator|.
name|arraycopy
argument_list|(
name|source
argument_list|,
name|sourceOffset
argument_list|,
name|data
argument_list|,
literal|0
argument_list|,
name|totalLength
argument_list|)
expr_stmt|;
block|}
block|}
return|return
operator|new
name|OggPage
argument_list|(
name|version
argument_list|,
name|bf1
argument_list|,
name|bos
argument_list|,
name|eos
argument_list|,
name|absoluteGranulePosition
argument_list|,
name|streamSerialNumber
argument_list|,
name|pageSequenceNumber
argument_list|,
name|pageCheckSum
argument_list|,
name|segmentOffsets
argument_list|,
name|segmentLengths
argument_list|,
name|totalLength
argument_list|,
name|header
argument_list|,
name|segmentTable
argument_list|,
name|data
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|EOFException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|EndOfOggStreamException
argument_list|()
throw|;
block|}
block|}
specifier|private
specifier|static
name|void
name|readFully
parameter_list|(
name|InputStream
name|source
parameter_list|,
name|byte
index|[]
name|buffer
parameter_list|)
throws|throws
name|IOException
block|{
name|int
name|total
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|total
operator|<
name|buffer
operator|.
name|length
condition|)
block|{
name|int
name|read
init|=
name|source
operator|.
name|read
argument_list|(
name|buffer
argument_list|,
name|total
argument_list|,
name|buffer
operator|.
name|length
operator|-
name|total
argument_list|)
decl_stmt|;
if|if
condition|(
name|read
operator|==
operator|-
literal|1
condition|)
block|{
throw|throw
operator|new
name|EndOfOggStreamException
argument_list|()
throw|;
block|}
name|total
operator|+=
name|read
expr_stmt|;
block|}
block|}
comment|/**      * Returns the absolute granule position of the last complete packet      * contained in this Ogg page, or -1 if the page contains a single packet,      * which is not completed on this page. For pages containing Vorbis data,      * this value is the sample index within the Vorbis stream. The Vorbis      * stream does not necessarily start with sample index 0.      *       * @return the absolute granule position of the last packet completed on      *         this page      */
specifier|public
name|long
name|getAbsoluteGranulePosition
parameter_list|()
block|{
return|return
name|absoluteGranulePosition
return|;
block|}
comment|/**      * Returns the stream serial number of this ogg page.      *       * @return this page's serial number      */
specifier|public
name|int
name|getStreamSerialNumber
parameter_list|()
block|{
return|return
name|streamSerialNumber
return|;
block|}
comment|/**      * Return the sequnce number of this ogg page.      *       * @return this page's sequence number      */
specifier|public
name|int
name|getPageSequenceNumber
parameter_list|()
block|{
return|return
name|pageSequenceNumber
return|;
block|}
comment|/**      * Return the check sum of this ogg page.      *       * @return this page's check sum      */
specifier|public
name|int
name|getPageCheckSum
parameter_list|()
block|{
return|return
name|pageCheckSum
return|;
block|}
comment|/**      * @return the total number of bytes in the page data      */
specifier|public
name|int
name|getTotalLength
parameter_list|()
block|{
if|if
condition|(
name|data
operator|!=
literal|null
condition|)
block|{
return|return
literal|27
operator|+
name|segmentTable
operator|.
name|length
operator|+
name|data
operator|.
name|length
return|;
block|}
else|else
block|{
return|return
name|totalLength
return|;
block|}
block|}
comment|/**      * @return a ByteBuffer containing the page data      */
specifier|public
name|byte
index|[]
name|getData
parameter_list|()
block|{
return|return
name|data
return|;
block|}
specifier|public
name|byte
index|[]
name|getHeader
parameter_list|()
block|{
return|return
name|header
return|;
block|}
specifier|public
name|byte
index|[]
name|getSegmentTable
parameter_list|()
block|{
return|return
name|segmentTable
return|;
block|}
specifier|public
name|int
index|[]
name|getSegmentOffsets
parameter_list|()
block|{
return|return
name|segmentOffsets
return|;
block|}
specifier|public
name|int
index|[]
name|getSegmentLengths
parameter_list|()
block|{
return|return
name|segmentLengths
return|;
block|}
comment|/**      * @return<code>true</code> if this page begins with a continued packet      */
specifier|public
name|boolean
name|isContinued
parameter_list|()
block|{
return|return
name|continued
return|;
block|}
comment|/**      * @return<code>true</code> if this page begins with a fresh packet      */
specifier|public
name|boolean
name|isFresh
parameter_list|()
block|{
return|return
operator|!
name|continued
return|;
block|}
comment|/**      * @return<code>true</code> if this page is the beginning of a logical      *         stream      */
specifier|public
name|boolean
name|isBos
parameter_list|()
block|{
return|return
name|bos
return|;
block|}
comment|/**      * @return<code>true</code> if this page is the end of a logical stream      */
specifier|public
name|boolean
name|isEos
parameter_list|()
block|{
return|return
name|eos
return|;
block|}
block|}
end_class

end_unit

